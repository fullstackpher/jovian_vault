---
创建时间: 2026-01-25T15:05
更新时间: 2026-01-27T16:53
tags:
  - JavaScript
---

> 作用域

- 定义：作用域控制标识符（变量，函数名）在何处可见及其生命周期
- 主要类型：全局作用域，函数作用域，块级作用域，模块作用域

> 全局作用域

- 说明：在全局创建的变量（例如在顶层使用var/let/const或不声明直接赋值）对整个脚本可见
- 在浏览器中，**全局var会成为[[window]]的属性**，而**let/const则不会**

> 函数作用域

- 说明：使用function创建的作用域；在函数内部声明的变量只在函数内可见
- 关键：var遵循函数作用域（在**函数内可访问**）即使在块内声明也是函数级可见

> 块级作用域

- 说明：由`{...}`（比如if/for）创建的作用域。**let和const遵循块级作用域，var不遵循**
- 示例：`if(true){let x = 1}` -> x在块外不可见

> 模块作用域

- 在ES模块（import/export）自身有**独立作用域**，顶层变量不会污染全局

> 词法作用域（Lexical Scope）与闭包

- 词法作用域：**作用域由代码书写位置决定，函数内可以访问定义时父级可见的变量**
- 闭包：当函数访问外部作用域的变量并在外部作用域执行上下文结束后仍可以使用这些变量时，形成[[闭包]]

> 提升（hositing）与TDZ

- 提升：var声明会被提升到函数或全局顶部，但其赋值不会。访问提升但未赋值的var变量会返回undefined
- TDZ（暂时性死区）：let/const声明存在TDZ，在声明之前访问会抛出ReferenceError
- 示例对比：
	- console.log(x); var x = 1; 输出undefined
	- console.log(y); let y = 1; 报错（在声明前访问）

> [!tip] 实用建议（最佳实践）

- 优先使用let/const，避免var带来的函数级混淆
- 使用const表示不变绑定，let可用于可变值
- 理解闭包有助于写异步代码与封装私有变量，但要注意内存泄漏风险
- 将变量的作用域尽量缩小到需要的最小范围