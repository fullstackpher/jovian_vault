---
创建时间: 2026-01-28T17:37
更新时间: 2026-01-28T21:21
tags:
  - JavaScript
---
## 原型

### 原型的概念

每个对象都有原型，原型也是个对象（模板对象）
实例就是根据这个模板创建出来的具体对象
对象可以继承原型的属性和方法

### 如何获取对象的原型

> [!note]+ 方式①：通过对象获取原型
> 

`对象.__proto__` （隐式原型）

> [!note]+ 方式②：通过对象的构造函数获取原型

`对象的构造函数.prototype` （显示原型）

### 对象、构造函数、原型之间的关系

> [!note]+ 构造函数与原型的关系

- 每个构造函数都有一个`prototype`属性，指向它的原型对象
- 原型对象都有一个`constructor`属性，指向它的构造函数

> [!note]+ 对象与原型的关系

- 每个对象都有一个`__proto__`属性（隐式原型）指向创建它的构造函数的原型
- 通过`new`关键字创建对象时，新对象会自动关联到构造函数的原型

> [!note]+ 对象与构造函数的关系

- 对象是通过构造函数创建的实例
- 构造函数定义了对象的初始属性和结构

> [!tip]+ 画张图梳理它们之间的关系：

[[原型构造函数对象之间的关系图]]

![](https://jovian-1257905003.cos.ap-shanghai.myqcloud.com/picture/原型构造函数对象之间的关系图.png)

### 自定义构造函数原型应用

> [!example]+ 示例：原型方法

```js
function User(name, age, address) {
	this.name = name
	this.age = age
	this.address = address
}

User.prototype.addShopCart = function (product) {
	console.log(`${this.name} 将 ${product} 加入购物车`);
}

User.prototype.buy = function (product) {
	console.log(`${this.name} 购买了 ${product}`);
}

var user = new User('张三', 18, '北京')
user.addShopCart('MacBook Pro')
user.buy('MacBook Pro')
console.log(user);
```

### 判断属性是否属于对象本身

`对象.hasOwnProperty('属性名')`

> [!example]+ 示例：判断对象自身的属性

```js
console.log(user.hasOwnProperty('name')); // true 对象自身的属性
console.log(user.hasOwnProperty('age')); // true 对象自身的属性
console.log(user.hasOwnProperty('address')); // true 对象自身的属性
console.log(user.hasOwnProperty('addShopCart')); // false 原型上的属性
console.log(user.hasOwnProperty('buy')); // false 原型上的属性
```

> [!tip]+ 只有属性在对象本身才返回true，否则都是false（原型上就是false）

### 创建对象的同时设置原型

> [!example]+ 创建对象指定原型

```js
// 创建对象的同时设置原型
var obj1 = {}
console.log(obj1);
console.log('');

// 创建对象的同时设置原型
var obj2 = Object.create([1, 2, 3, 4])
console.log(obj2);
console.log('');

// 创建对象的同时设置原型
var obj3 = Object.create(new String('hello'))
console.log(obj3);
console.log('');

// 创建没有原型的对象
var obj4 = Object.create(null)
console.log(obj4);
console.log('');
```

> [!tip]+ Object.create()
> `Object.create()` 是 ES6 创建对象的另一种方式，可以理解为**继承**一个对象, 添加的属性是在原型下。

---

## 原型链

### 什么是原型链

每个对象都有原型，原型还是个对象，那原型也有原型，原型的原型也有原型，组成了原型链

### 原型链的作用

> [!tip]+ 属性查找
> 先从对象本身开始找，如果找不到，就沿着原型链向上找，直到原型链的终点
> 如果原型链的终点也没有，就返回undefined

![](https://jovian-1257905003.cos.ap-shanghai.myqcloud.com/picture/原型链关系示意图.png)


### 原型链和构造函数

- **Object**、**Array**、**自定义函数**等所有函数的原型是 `Function.prototype`，Function.prototype的构造函数是`Object`
- `Function.__proto__` 等于 `Function.prototype`，Function的构造函数是自己

### instanceof和原型链

`instanceof` 运算符的工作原理 ：

- 检查右侧构造函数的 prototype 属性是否存在于左侧对象的原型链上

`对象 instanceof 构造函数`

> [!tip]+ instanceof会随着原型链向上查找

> [!danger]+ 注意事项
> 1. 基本数据类型都会返回false，使用包装对象才可以
> 2. 修改prototype，它会指向旧的原型（一般不建议这么做）

> [!success]+ 实际应用中的注意事项

- 避免修改已使用构造函数的原型 ：
	- 如果构造函数已经被用来创建实例，修改其 `prototype` 会导致现有实例与构造函数的关系断裂
	- 这可能会引起难以排查的 bug

- 正确的原型扩展方式 ：
	- 应该 扩展 原型，而不是 替换 原型
	- 错误做法： `A.prototype = {}` （替换整个原型）
	- 正确做法： `A.prototype.method = function() {}` （在原有原型上添加方法）

- 理解原型链的动态性 ：
	- 虽然对象的 `__proto__` 指向固定，但原型对象本身是可以修改的
	- 如果修改原型对象的属性或方法，所有指向该原型的实例都会受到影响

### 关于constructor属性

- 原型对象都有一个`constructor`属性，指向它的构造函数

