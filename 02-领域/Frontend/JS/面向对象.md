---
创建时间: 2026-01-26T12:30
更新时间: 2026-01-28T18:33
tags:
  - JavaScript
---
在JS中一切皆对象，数组，函数都是对象的一种

## Object 对象

### 认识对象

对象是 **键值对** 的无序集合，表示属性和值的映射关系

- Object类型的数据由属性组成，属性由属性名和属性值组成
- 属性值可以是任意类型的数据
- 属性名符合标识符命名规则，则省略引号
- 属性为函数的话，该属性可以被称为方法

语法：
- key和value之间用冒号分隔，每组key-value之间用逗号分隔，最后一组省略逗号


### 声明Object对象

#### 直接量方式

```js
const user = {
	username: 'Jovian',
	age: 28,
	'home-address' : '上海',
	schollAddress: '北京',
	hobbies: ['游戏', '唱歌'],
	child: {
		name: 'Jee',
		age: 3
	},
	getInfo: function() {
		console.log('obj2 getInfo');
	},
	eat: function() {
		console.log('jee爱吃');
	}
}
```

#### Object函数

```js
const obj = Object();
```

#### Object构造函数

```js
const obj = new Object();
```

### Object对象属性的读写

##### ①语法

> 属性访问

```js
对象.属性名
对象['属性名']
```

>[!danger] 注意事项：访问不存在的属性和方法
>1. 访问不存在的属性会返回：undefined
>2. 访问不存在的方法会报错：Uncaught TypeError: user.drink is not a function

> 属性修改

```js
对象.属性名 = value
对象['属性名'] = value
```

#### ②什么情况下必须使用 `[]`方式读写属性

> 情况一：属性名不符合标识符规范
- 例如：`user.home-address`这种，最终只会解析`address`，并报一个未定义的错误
- `console.log(user['home-address'])`

> 情况二：用变量表示属性名

```js
var prop = 'hobbies'
console.log(user.prop) // undefined
console.log(user[prop]) // ['游戏', '唱歌']
```

### 遍历 Object 对象的属性

```js
for (var key in 对象) {
	key //属性名
	对象[i] //属性值
}
```

### 删除对象中的属性

```js
delete 对象.属性名
delete 对象['属性名']
```

### 判断对象中是否存在某个属性

```js
// 表达式的值是布尔值
'属性名' in 对象
```

---

## 构造函数

### 什么是构造函数

1. 构造函数就是其他编程语言的类 (ES6引入类的概念)
2. 构造函数对对象进行描述，描述对象的特点，每个对象都有构造函数，相同数据类型的对象构造函数是同一个，如所有数组的构造函数都是Array，所有函数的构造函数都是Function

> [!tip]+ 构造函数对应的是数据类型！！！

### 构造函数和对象的关系

1. 构造函数是类的描述，对象是构造函数的实例
2. 一个构造函数可以对应无数个对象
3. 一个对象只能对应一个构造函数

### 判断对象的构造函数（数据类型）
#### ① 运算符 instanceof

```js
对象 instanceof 构造函数; // 表达式的值是布尔值
```

#### ② constructor 属性

```js
对象.constructor; // 直接获取到该对象的构造函数
```

### 实例化

```js
new 构造函数();
```

1. 每实例化一次构造函数，就创建一个对象
2. 每个对象都有独立的内存空间

### 自定义构造函数

ES5支持通过function 大写函数名的方式创建对象，这种方式叫做自定义构造函数
通过[[this]]指定对象的引用，函数的参数就是对象的属性

> [!example]+

```js
function User(username, age) {
    this.username = username
    this.age = age
    
    this.getInfo = function() {
        console.log(`my name is ${this.username}, I am ${this.age} years old`);
    }
}
// 实例化对象
var user1 = new User('Jovian', 28)
console.log(user1);
user1.getInfo()
```

> [!tip]+ 自定义构造函数的返回值对实例化结果的影响：
> 1. 如果构造函数中没有return或return的是原始类型数据，实例化的结果就是创建的新对象
> 2. 如果构造函数中指定return的是对象类型，实例化的结果就是return的数据

### 构造函数和函数

> [!tip]+ 构造函数与函数的区别：
> 一个函数如果去实例化它，它就是构造函数，如果去调用它，它就是函数

```js
Array();  // 当函数用
new Array(); // 当构造函数用
```

### 原始类型数据的对象特性

原始类型数据：Number、String、Boolean，既有值的状态，也有对象的状态

> [!example]+

```js
// 创建数字，直接量方式，值的状态
var num01  = 100
// 创建数字 Number函数方式，值的状态
var num02 = Number(100)
// 创建数字 Number构造函数 对象的装填
var num03 = new Number(100)

// 不管处于什么状态，需要什么形式转为什么形式
console.log(num01 * num03)

console.log(num03.constructor)

// num01 自动包装成对象
console.log(num01.constructor)

// num02 自动包装成对象
console.log(num02.constructor)


```

### 临时包装对象

> [!note]+ 原始类型与对象的区别
>>[!tip] 原始类型（String、Number、Boolean、Symbol、BigInt）在JavaScript中不是对象

> [!tip]+ 临时包装对象的创建
> 1. 当我们访问str.length时，JavaScript会临时创建一个String对象实例
> 2. 这个临时对象拥有length属性和其他字符串方法
> 3. 访问完成后，这个临时对象会被立刻销毁

****

## 面向对象与原型的关系
### JavaScript 如何实现 OOP 特性？
1. 封装 ：通过对象字面量或构造函数创建对象，包含属性和方法
2. 继承 ：通过原型链实现（子对象链接到父对象的[[原型]]）
3. 多态 ：通过重写原型方法实现（子对象可以覆盖父对象的方法）


